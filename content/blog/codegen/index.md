---
title: "Code Generation and Lazy Programmers"
tags: ["python", "automation"]
published: true
date: "2019-09-10"
dateComment: ""
---

On Friday I took an issue to create yet another generic CRUD endpoint. I don't know how many of these I've written as a full-stack developer, but it is too many. Of course once the process has been fine-tuned it is pretty much copy and paste then find and replace the table name and a few other things. I didn't want to do more of this, and besides, the more of these there are the more of a maintenance headache they become. (Imagine changing out the database abstraction used in the get call x 100 endpoints! And don't forget that each developer, and you, did things just a little different each time, preferences change, after all.)

Software developers spend so much time automating, why are we wasting time on such things?

There has to be a better way!

Enter jinja2 and some templating. It was the end of the day when I took that task, and I was feeling motivated, so I spent that evening writing a code generator. It's pretty basic, only around sixty lines even, but it should save the team a few hours or more every week in new CRUD API writing, and countless hours in maintenance for these same modules.

It's not quite ready for public consumption yet, but I'll link it, and hopefully by the time someone reads this it will be.

[Codegen GitHub](https://github.com/TomFaulkner/codegen)

My plans for this, should my team agree, is that these basic CRUD API endpoints won't exist in our codebase as code any longer, but instead as templates and minimal configs. That way all of these basic modules will be built at microservice build time and updating them all will be as simple as updating the template, or perhaps versioning the template and updating the defaults file to use the new template version.

The workflow should look something like this,

```shell
codegen dir service/configs
black service  # because even generated code should be pretty code
nose2 -vs service/tests/unit  # autogenerated templated unit tests, because test all the things
# do more buildy things
```

Three hours of time, which included writing the first template, and thinking through how I wanted to approach this, will pay for itself in the first week, and pay for itself hundreds of times over in the first year. Now the real question should be why didn't I do this a year ago?
